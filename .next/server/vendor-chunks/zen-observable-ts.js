"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zen-observable-ts";
exports.ids = ["vendor-chunks/zen-observable-ts"];
exports.modules = {

/***/ "(ssr)/./node_modules/zen-observable-ts/module.js":
/*!**************************************************!*\
  !*** ./node_modules/zen-observable-ts/module.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observable: () => (/* binding */ Observable)\n/* harmony export */ });\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\n// === Symbol Support ===\nvar hasSymbols = function() {\n    return typeof Symbol === \"function\";\n};\nvar hasSymbol = function(name) {\n    return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function(name) {\n    return hasSymbol(name) ? Symbol[name] : \"@@\" + name;\n};\nif (hasSymbols() && !hasSymbol(\"observable\")) {\n    Symbol.observable = Symbol(\"observable\");\n}\nvar SymbolIterator = getSymbol(\"iterator\");\nvar SymbolObservable = getSymbol(\"observable\");\nvar SymbolSpecies = getSymbol(\"species\"); // === Abstract Operations ===\nfunction getMethod(obj, key) {\n    var value = obj[key];\n    if (value == null) return undefined;\n    if (typeof value !== \"function\") throw new TypeError(value + \" is not a function\");\n    return value;\n}\nfunction getSpecies(obj) {\n    var ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(e) {\n    if (hostReportError.log) {\n        hostReportError.log(e);\n    } else {\n        setTimeout(function() {\n            throw e;\n        });\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(function() {\n        try {\n            fn();\n        } catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    var cleanup = subscription._cleanup;\n    if (cleanup === undefined) return;\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        } else {\n            var unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    } catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    var queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for(var i = 0; i < queue.length; ++i){\n        notifySubscription(subscription, queue[i].type, queue[i].value);\n        if (subscription._state === \"closed\") break;\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    var observer = subscription._observer;\n    try {\n        var m = getMethod(observer, type);\n        switch(type){\n            case \"next\":\n                if (m) m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m) m.call(observer, value);\n                else throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m) m.call(observer);\n                break;\n        }\n    } catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") cleanupSubscription(subscription);\n    else if (subscription._state === \"running\") subscription._state = \"ready\";\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") return;\n    if (subscription._state === \"buffering\") {\n        subscription._queue.push({\n            type: type,\n            value: value\n        });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [\n            {\n                type: type,\n                value: value\n            }\n        ];\n        enqueue(function() {\n            return flushSubscription(subscription);\n        });\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nvar Subscription = /*#__PURE__*/ function() {\n    function Subscription(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        var subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        } catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") this._state = \"ready\";\n    }\n    var _proto = Subscription.prototype;\n    _proto.unsubscribe = function unsubscribe() {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    };\n    _createClass(Subscription, [\n        {\n            key: \"closed\",\n            get: function() {\n                return this._state === \"closed\";\n            }\n        }\n    ]);\n    return Subscription;\n}();\nvar SubscriptionObserver = /*#__PURE__*/ function() {\n    function SubscriptionObserver(subscription) {\n        this._subscription = subscription;\n    }\n    var _proto2 = SubscriptionObserver.prototype;\n    _proto2.next = function next(value) {\n        onNotify(this._subscription, \"next\", value);\n    };\n    _proto2.error = function error(value) {\n        onNotify(this._subscription, \"error\", value);\n    };\n    _proto2.complete = function complete() {\n        onNotify(this._subscription, \"complete\");\n    };\n    _createClass(SubscriptionObserver, [\n        {\n            key: \"closed\",\n            get: function() {\n                return this._subscription._state === \"closed\";\n            }\n        }\n    ]);\n    return SubscriptionObserver;\n}();\nvar Observable = /*#__PURE__*/ function() {\n    function Observable(subscriber) {\n        if (!(this instanceof Observable)) throw new TypeError(\"Observable cannot be called as a function\");\n        if (typeof subscriber !== \"function\") throw new TypeError(\"Observable initializer must be a function\");\n        this._subscriber = subscriber;\n    }\n    var _proto3 = Observable.prototype;\n    _proto3.subscribe = function subscribe(observer) {\n        if (typeof observer !== \"object\" || observer === null) {\n            observer = {\n                next: observer,\n                error: arguments[1],\n                complete: arguments[2]\n            };\n        }\n        return new Subscription(observer, this._subscriber);\n    };\n    _proto3.forEach = function forEach(fn) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve();\n            }\n            var subscription = _this.subscribe({\n                next: function(value) {\n                    try {\n                        fn(value, done);\n                    } catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve\n            });\n        });\n    };\n    _proto3.map = function map(fn) {\n        var _this2 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            return _this2.subscribe({\n                next: function(value) {\n                    try {\n                        value = fn(value);\n                    } catch (e) {\n                        return observer.error(e);\n                    }\n                    observer.next(value);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.filter = function filter(fn) {\n        var _this3 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            return _this3.subscribe({\n                next: function(value) {\n                    try {\n                        if (!fn(value)) return;\n                    } catch (e) {\n                        return observer.error(e);\n                    }\n                    observer.next(value);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.reduce = function reduce(fn) {\n        var _this4 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        var hasSeed = arguments.length > 1;\n        var hasValue = false;\n        var seed = arguments[1];\n        var acc = seed;\n        return new C(function(observer) {\n            return _this4.subscribe({\n                next: function(value) {\n                    var first = !hasValue;\n                    hasValue = true;\n                    if (!first || hasSeed) {\n                        try {\n                            acc = fn(acc, value);\n                        } catch (e) {\n                            return observer.error(e);\n                        }\n                    } else {\n                        acc = value;\n                    }\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    if (!hasValue && !hasSeed) return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                    observer.next(acc);\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.concat = function concat() {\n        var _this5 = this;\n        for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){\n            sources[_key] = arguments[_key];\n        }\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            var subscription;\n            var index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next: function(v) {\n                        observer.next(v);\n                    },\n                    error: function(e) {\n                        observer.error(e);\n                    },\n                    complete: function() {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        } else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    }\n                });\n            }\n            startNext(_this5);\n            return function() {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    };\n    _proto3.flatMap = function flatMap(fn) {\n        var _this6 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            var subscriptions = [];\n            var outer = _this6.subscribe({\n                next: function(value) {\n                    if (fn) {\n                        try {\n                            value = fn(value);\n                        } catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    var inner = C.from(value).subscribe({\n                        next: function(value) {\n                            observer.next(value);\n                        },\n                        error: function(e) {\n                            observer.error(e);\n                        },\n                        complete: function() {\n                            var i = subscriptions.indexOf(inner);\n                            if (i >= 0) subscriptions.splice(i, 1);\n                            completeIfDone();\n                        }\n                    });\n                    subscriptions.push(inner);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    completeIfDone();\n                }\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) observer.complete();\n            }\n            return function() {\n                subscriptions.forEach(function(s) {\n                    return s.unsubscribe();\n                });\n                outer.unsubscribe();\n            };\n        });\n    };\n    _proto3[SymbolObservable] = function() {\n        return this;\n    };\n    Observable.from = function from(x) {\n        var C = typeof this === \"function\" ? this : Observable;\n        if (x == null) throw new TypeError(x + \" is not an object\");\n        var method = getMethod(x, SymbolObservable);\n        if (method) {\n            var observable = method.call(x);\n            if (Object(observable) !== observable) throw new TypeError(observable + \" is not an object\");\n            if (isObservable(observable) && observable.constructor === C) return observable;\n            return new C(function(observer) {\n                return observable.subscribe(observer);\n            });\n        }\n        if (hasSymbol(\"iterator\")) {\n            method = getMethod(x, SymbolIterator);\n            if (method) {\n                return new C(function(observer) {\n                    enqueue(function() {\n                        if (observer.closed) return;\n                        for(var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;){\n                            var item = _step.value;\n                            observer.next(item);\n                            if (observer.closed) return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(function(observer) {\n                enqueue(function() {\n                    if (observer.closed) return;\n                    for(var i = 0; i < x.length; ++i){\n                        observer.next(x[i]);\n                        if (observer.closed) return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    };\n    Observable.of = function of() {\n        for(var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            items[_key2] = arguments[_key2];\n        }\n        var C = typeof this === \"function\" ? this : Observable;\n        return new C(function(observer) {\n            enqueue(function() {\n                if (observer.closed) return;\n                for(var i = 0; i < items.length; ++i){\n                    observer.next(items[i]);\n                    if (observer.closed) return;\n                }\n                observer.complete();\n            });\n        });\n    };\n    _createClass(Observable, null, [\n        {\n            key: SymbolSpecies,\n            get: function() {\n                return this;\n            }\n        }\n    ]);\n    return Observable;\n}();\nif (hasSymbols()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError: hostReportError\n        },\n        configurable: true\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvemVuLW9ic2VydmFibGUtdHMvbW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQSxnQ0FBZ0NDLENBQUMsRUFBRUMsY0FBYztJQUFJLElBQUlDLEtBQUssT0FBT0MsV0FBVyxlQUFlSCxDQUFDLENBQUNHLE9BQU9DLFFBQVEsQ0FBQyxJQUFJSixDQUFDLENBQUMsYUFBYTtJQUFFLElBQUlFLElBQUksT0FBTyxDQUFDQSxLQUFLQSxHQUFHRyxJQUFJLENBQUNMLEVBQUMsRUFBR00sSUFBSSxDQUFDQyxJQUFJLENBQUNMO0lBQUssSUFBSU0sTUFBTUMsT0FBTyxDQUFDVCxNQUFPRSxDQUFBQSxLQUFLUSw0QkFBNEJWLEVBQUMsS0FBTUMsa0JBQWtCRCxLQUFLLE9BQU9BLEVBQUVXLE1BQU0sS0FBSyxVQUFVO1FBQUUsSUFBSVQsSUFBSUYsSUFBSUU7UUFBSSxJQUFJVSxJQUFJO1FBQUcsT0FBTztZQUFjLElBQUlBLEtBQUtaLEVBQUVXLE1BQU0sRUFBRSxPQUFPO2dCQUFFRSxNQUFNO1lBQUs7WUFBRyxPQUFPO2dCQUFFQSxNQUFNO2dCQUFPQyxPQUFPZCxDQUFDLENBQUNZLElBQUk7WUFBQztRQUFHO0lBQUc7SUFBRSxNQUFNLElBQUlHLFVBQVU7QUFBMEk7QUFFM2xCLFNBQVNMLDRCQUE0QlYsQ0FBQyxFQUFFZ0IsTUFBTTtJQUFJLElBQUksQ0FBQ2hCLEdBQUc7SUFBUSxJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPaUIsa0JBQWtCakIsR0FBR2dCO0lBQVMsSUFBSUUsSUFBSUMsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNoQixJQUFJLENBQUNMLEdBQUdzQixLQUFLLENBQUMsR0FBRyxDQUFDO0lBQUksSUFBSUosTUFBTSxZQUFZbEIsRUFBRXVCLFdBQVcsRUFBRUwsSUFBSWxCLEVBQUV1QixXQUFXLENBQUNDLElBQUk7SUFBRSxJQUFJTixNQUFNLFNBQVNBLE1BQU0sT0FBTyxPQUFPVixNQUFNaUIsSUFB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T0FBT2tCLGNBQWMsQ0FBQ21CLFlBQVlyRCxPQUFPLGVBQWU7UUFDdERXLE9BQU87WUFDTDhILFFBQVEzRjtZQUNSVSxpQkFBaUJBO1FBQ25CO1FBQ0F4QixjQUFjO0lBQ2hCO0FBQ0Y7QUFFc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mdXJuaS1hcHAvLi9ub2RlX21vZHVsZXMvemVuLW9ic2VydmFibGUtdHMvbW9kdWxlLmpzP2Y3OWYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyByZXR1cm4gZnVuY3Rpb24gKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLy8gPT09IFN5bWJvbCBTdXBwb3J0ID09PVxudmFyIGhhc1N5bWJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGhhc1N5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBoYXNTeW1ib2xzKCkgJiYgQm9vbGVhbihTeW1ib2xbbmFtZV0pO1xufTtcblxudmFyIGdldFN5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBoYXNTeW1ib2wobmFtZSkgPyBTeW1ib2xbbmFtZV0gOiAnQEAnICsgbmFtZTtcbn07XG5cbmlmIChoYXNTeW1ib2xzKCkgJiYgIWhhc1N5bWJvbCgnb2JzZXJ2YWJsZScpKSB7XG4gIFN5bWJvbC5vYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG59XG5cbnZhciBTeW1ib2xJdGVyYXRvciA9IGdldFN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTeW1ib2xPYnNlcnZhYmxlID0gZ2V0U3ltYm9sKCdvYnNlcnZhYmxlJyk7XG52YXIgU3ltYm9sU3BlY2llcyA9IGdldFN5bWJvbCgnc3BlY2llcycpOyAvLyA9PT0gQWJzdHJhY3QgT3BlcmF0aW9ucyA9PT1cblxuZnVuY3Rpb24gZ2V0TWV0aG9kKG9iaiwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWVzKG9iaikge1xuICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcblxuICBpZiAoY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3RvciA9IGN0b3JbU3ltYm9sU3BlY2llc107XG5cbiAgICBpZiAoY3RvciA9PT0gbnVsbCkge1xuICAgICAgY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3RvciAhPT0gdW5kZWZpbmVkID8gY3RvciA6IE9ic2VydmFibGU7XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgT2JzZXJ2YWJsZTsgLy8gU1BFQzogQnJhbmQgY2hlY2tcbn1cblxuZnVuY3Rpb24gaG9zdFJlcG9ydEVycm9yKGUpIHtcbiAgaWYgKGhvc3RSZXBvcnRFcnJvci5sb2cpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IubG9nKGUpO1xuICB9IGVsc2Uge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlKGZuKSB7XG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhvc3RSZXBvcnRFcnJvcihlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fY2xlYW51cDtcbiAgaWYgKGNsZWFudXAgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBzdWJzY3JpcHRpb24uX2NsZWFudXAgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFjbGVhbnVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVuc3Vic2NyaWJlID0gZ2V0TWV0aG9kKGNsZWFudXAsICd1bnN1YnNjcmliZScpO1xuXG4gICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgdW5zdWJzY3JpYmUuY2FsbChjbGVhbnVwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IoZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHN1YnNjcmlwdGlvbi5fb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fcXVldWUgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAnY2xvc2VkJztcbn1cblxuZnVuY3Rpb24gZmx1c2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHZhciBxdWV1ZSA9IHN1YnNjcmlwdGlvbi5fcXVldWU7XG5cbiAgaWYgKCFxdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN1YnNjcmlwdGlvbi5fcXVldWUgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAncmVhZHknO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICBub3RpZnlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCBxdWV1ZVtpXS50eXBlLCBxdWV1ZVtpXS52YWx1ZSk7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnKSBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBub3RpZnlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCB0eXBlLCB2YWx1ZSkge1xuICBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ3J1bm5pbmcnO1xuICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX29ic2VydmVyO1xuXG4gIHRyeSB7XG4gICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIsIHR5cGUpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBpZiAobSkgbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7ZWxzZSB0aHJvdyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhvc3RSZXBvcnRFcnJvcihlKTtcbiAgfVxuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJykgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO2Vsc2UgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdydW5uaW5nJykgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdyZWFkeSc7XG59XG5cbmZ1bmN0aW9uIG9uTm90aWZ5KHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnKSByZXR1cm47XG5cbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdidWZmZXJpbmcnKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9xdWV1ZS5wdXNoKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlICE9PSAncmVhZHknKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdidWZmZXJpbmcnO1xuICAgIHN1YnNjcmlwdGlvbi5fcXVldWUgPSBbe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH1dO1xuICAgIGVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZsdXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbm90aWZ5U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpO1xufVxuXG52YXIgU3Vic2NyaXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gICAgLy8gQVNTRVJUOiBvYnNlcnZlciBpcyBhbiBvYmplY3RcbiAgICAvLyBBU1NFUlQ6IHN1YnNjcmliZXIgaXMgY2FsbGFibGVcbiAgICB0aGlzLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5fcXVldWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhdGUgPSAnaW5pdGlhbGl6aW5nJztcbiAgICB2YXIgc3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fY2xlYW51cCA9IHN1YnNjcmliZXIuY2FsbCh1bmRlZmluZWQsIHN1YnNjcmlwdGlvbk9ic2VydmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdWJzY3JpcHRpb25PYnNlcnZlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdpbml0aWFsaXppbmcnKSB0aGlzLl9zdGF0ZSA9ICdyZWFkeSc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3Vic2NyaXB0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8udW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTtcbiAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdWJzY3JpcHRpb24sIFt7XG4gICAga2V5OiBcImNsb3NlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSAnY2xvc2VkJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb25PYnNlcnZlcihzdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFN1YnNjcmlwdGlvbk9ic2VydmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLm5leHQgPSBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnbmV4dCcsIHZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8yLmVycm9yID0gZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICBvbk5vdGlmeSh0aGlzLl9zdWJzY3JpcHRpb24sICdlcnJvcicsIHZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8yLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnY29tcGxldGUnKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3Vic2NyaXB0aW9uT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcImNsb3NlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdWJzY3JpcHRpb25PYnNlcnZlcjtcbn0oKTtcblxudmFyIE9ic2VydmFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ic2VydmFibGUgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYnNlcnZhYmxlIGluaXRpYWxpemVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMuX3N1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBPYnNlcnZhYmxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgbmV4dDogb2JzZXJ2ZXIsXG4gICAgICAgIGVycm9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIGNvbXBsZXRlOiBhcmd1bWVudHNbMl1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX3N1YnNjcmliZXIpO1xuICB9O1xuXG4gIF9wcm90bzMuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4odmFsdWUsIGRvbmUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMubWFwID0gZnVuY3Rpb24gbWFwKGZuKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGZuKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWZuKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5yZWR1Y2UgPSBmdW5jdGlvbiByZWR1Y2UoZm4pIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgIHZhciBoYXNTZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHNlZWQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGFjYyA9IHNlZWQ7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIF90aGlzNC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgZmlyc3QgPSAhaGFzVmFsdWU7XG4gICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFmaXJzdCB8fCBoYXNTZWVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhY2MgPSBmbihhY2MsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2MgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzVmFsdWUgJiYgIWhhc1NlZWQpIHJldHVybiBvYnNlcnZlci5lcnJvcihuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVkdWNlIGFuIGVtcHR5IHNlcXVlbmNlJykpO1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoYWNjKTtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8zLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgc291cmNlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0TmV4dChuZXh0KSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IG5leHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydE5leHQoQy5mcm9tKHNvdXJjZXNbaW5kZXgrK10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzdGFydE5leHQoX3RoaXM1KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5mbGF0TWFwID0gZnVuY3Rpb24gZmxhdE1hcChmbikge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgdmFyIG91dGVyID0gX3RoaXM2LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5uZXIgPSBDLmZyb20odmFsdWUpLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKGlubmVyKTtcbiAgICAgICAgICAgICAgaWYgKGkgPj0gMCkgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIGNvbXBsZXRlSWZEb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKGlubmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcGxldGVJZkRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlSWZEb25lKCkge1xuICAgICAgICBpZiAob3V0ZXIuY2xvc2VkICYmIHN1YnNjcmlwdGlvbnMubGVuZ3RoID09PSAwKSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0ZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvM1tTeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBPYnNlcnZhYmxlLmZyb20gPSBmdW5jdGlvbiBmcm9tKHgpIHtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6IE9ic2VydmFibGU7XG4gICAgaWYgKHggPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZCh4LCBTeW1ib2xPYnNlcnZhYmxlKTtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbWV0aG9kLmNhbGwoeCk7XG4gICAgICBpZiAoT2JqZWN0KG9ic2VydmFibGUpICE9PSBvYnNlcnZhYmxlKSB0aHJvdyBuZXcgVHlwZUVycm9yKG9ic2VydmFibGUgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgIGlmIChpc09ic2VydmFibGUob2JzZXJ2YWJsZSkgJiYgb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzU3ltYm9sKCdpdGVyYXRvcicpKSB7XG4gICAgICBtZXRob2QgPSBnZXRNZXRob2QoeCwgU3ltYm9sSXRlcmF0b3IpO1xuXG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShtZXRob2QuY2FsbCh4KSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbSk7XG4gICAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHhbaV0pO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3Qgb2JzZXJ2YWJsZScpO1xuICB9O1xuXG4gIE9ic2VydmFibGUub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogT2JzZXJ2YWJsZTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGUsIG51bGwsIFt7XG4gICAga2V5OiBTeW1ib2xTcGVjaWVzLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmFibGU7XG59KCk7XG5cbmlmIChoYXNTeW1ib2xzKCkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGUsIFN5bWJvbCgnZXh0ZW5zaW9ucycpLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHN5bWJvbDogU3ltYm9sT2JzZXJ2YWJsZSxcbiAgICAgIGhvc3RSZXBvcnRFcnJvcjogaG9zdFJlcG9ydEVycm9yXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCB7IE9ic2VydmFibGUgfTtcbiJdLCJuYW1lcyI6WyJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlIiwibyIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNhbGwiLCJuZXh0IiwiYmluZCIsIkFycmF5IiwiaXNBcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsImxlbmd0aCIsImkiLCJkb25lIiwidmFsdWUiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiZnJvbSIsInRlc3QiLCJhcnIiLCJsZW4iLCJhcnIyIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiaGFzU3ltYm9scyIsImhhc1N5bWJvbCIsIkJvb2xlYW4iLCJnZXRTeW1ib2wiLCJvYnNlcnZhYmxlIiwiU3ltYm9sSXRlcmF0b3IiLCJTeW1ib2xPYnNlcnZhYmxlIiwiU3ltYm9sU3BlY2llcyIsImdldE1ldGhvZCIsIm9iaiIsInVuZGVmaW5lZCIsImdldFNwZWNpZXMiLCJjdG9yIiwiT2JzZXJ2YWJsZSIsImlzT2JzZXJ2YWJsZSIsIngiLCJob3N0UmVwb3J0RXJyb3IiLCJlIiwibG9nIiwic2V0VGltZW91dCIsImVucXVldWUiLCJmbiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImNsZWFudXBTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJjbGVhbnVwIiwiX2NsZWFudXAiLCJ1bnN1YnNjcmliZSIsImNsb3NlU3Vic2NyaXB0aW9uIiwiX29ic2VydmVyIiwiX3F1ZXVlIiwiX3N0YXRlIiwiZmx1c2hTdWJzY3JpcHRpb24iLCJxdWV1ZSIsIm5vdGlmeVN1YnNjcmlwdGlvbiIsInR5cGUiLCJvYnNlcnZlciIsIm0iLCJvbk5vdGlmeSIsInB1c2giLCJTdWJzY3JpcHRpb24iLCJzdWJzY3JpYmVyIiwic3Vic2NyaXB0aW9uT2JzZXJ2ZXIiLCJTdWJzY3JpcHRpb25PYnNlcnZlciIsImVycm9yIiwiX3Byb3RvIiwiZ2V0IiwiX3N1YnNjcmlwdGlvbiIsIl9wcm90bzIiLCJjb21wbGV0ZSIsIl9zdWJzY3JpYmVyIiwiX3Byb3RvMyIsInN1YnNjcmliZSIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfdGhpcyIsInJlamVjdCIsIm1hcCIsIl90aGlzMiIsIkMiLCJmaWx0ZXIiLCJfdGhpczMiLCJyZWR1Y2UiLCJfdGhpczQiLCJoYXNTZWVkIiwiaGFzVmFsdWUiLCJzZWVkIiwiYWNjIiwiZmlyc3QiLCJjb25jYXQiLCJfdGhpczUiLCJfbGVuIiwic291cmNlcyIsIl9rZXkiLCJpbmRleCIsInN0YXJ0TmV4dCIsInYiLCJmbGF0TWFwIiwiX3RoaXM2Iiwic3Vic2NyaXB0aW9ucyIsIm91dGVyIiwiaW5uZXIiLCJpbmRleE9mIiwic3BsaWNlIiwiY29tcGxldGVJZkRvbmUiLCJjbG9zZWQiLCJzIiwibWV0aG9kIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJpdGVtIiwib2YiLCJfbGVuMiIsIml0ZW1zIiwiX2tleTIiLCJzeW1ib2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zen-observable-ts/module.js\n");

/***/ })

};
;